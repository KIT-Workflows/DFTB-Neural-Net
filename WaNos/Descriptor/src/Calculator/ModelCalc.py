"""

This Module is designed for the implementation of the numerical force calculator.
Currently Haven't include the scaling factor since it is prone to error.

"""

import os
import time
import numpy as np
import pandas as pd
import h5py
import src.Calculator.ModelIO as ModelIO
import src.Calculator.SymmFuncIndPython as SymmFuncInd
import sys
import src.Calculator.ForceNum as ForceNum


from ase.calculators.calculator import Calculator, all_changes
from src.Calculator.NeuralCalc import NeuralCalc
import src.Calculator.src_nogrd as src_nogrd
from keras.models import load_model
import src.Utils.DirNav as DirNav


xyz_str_dict = {'x':0,  'y': 1,  'z': 2} # To Translate xyz_str to number


def inp_to_energy(model, inp):
    """Use NN Model to predict the energy based on the inp

            Args:
                model: a Keras model for the energy prediction
                inp: input vector for a particular molecule

            Outputs:
                energy: energy of the particular molecule

    Comment:
    A Pure Function.
    """
    scaled_energy = model.predict(inp)
    energy = scaled_energy.T[0]
    return energy





class ModelCalc(NeuralCalc):
    """
    ModelCalc is a child class of NeuralCalc, but model calc uses the
    entire trained model, and supports Read and Write .h5 file.

    Saves a keras model in attribute, which needs to be imported by a '.h5' file.abs
    To modulate, it is recommended to implement the training of the model using a
    separate module rather than inheriting from this class.

    Update:
    !!!Currently, ModelCalc is only for the numerical force calculation.
    """
    implemented_properties = ['energy', 'forces', 'stress', 'denergy', 'dforces']
    default_parameters = {'xc': 'ynn'}


    def __init__(self, calc, **kwargs):
        Calculator.__init__(self, **kwargs)
        """
            Args:
                calc: the ase.calculator used for the calculation.
                        Default: a DFTB calculator. Should be consistent
                        with the calculator used for training.

        """
        self.init_model = None
        self.Gparam_dict = None  # To store the prameters for symmetry function
        self.at_idx_map = None   # To store atom idx map
        self.calc = calc
        self.calc_properties = {}
        self.e_ref_calc = 0     # Reference Point for energy of given calculator
        self.e_ref_dft = 0     # Reference Point for DFT
        #self.dE_ref = -7685.457972419566 + 389.0714894952025 # Represent the difference between reference energy
        self.need_compile = False

    def initialize(self, atoms):

        """
        Will Convert the atom into the input.
        """
        # Do the DFTB Calculation and get the feature
        self.n_atoms = len(atoms)

        self.at_idx_map = src_nogrd.at_idx_map_generator(atoms)


        no_Gparam_dict = self.Gparam_dict == None
        not_imported = no_Gparam_dict


        if not_imported:
            raise ImportError("ModelCalc::initialize: the model has not been imported")

        if self.calc == None:
            raise ImportError("ModelCalc:initiaalize: No Calculator is found ")

        atom_cp = atoms.copy()
        atom_cp.set_calculator(self.calc)
        self.dE_ref = self.e_ref_dft - self.e_ref_calc
        # While Doing DFTB calculation, generate file under the /Calculator/calc folder
        #project_dir = get_project_dir()
        #calc_path = os.path.join(project_dir, 'Calculator', 'calc')
        #os.chdir(calc_path)
        # Then Calculate All the Properties using the designated Calculator.
        calc_e  = atom_cp.get_potential_energy() # The Energy Generated by the calculator
        # calc_force = atom_cp.get_forces() # The Froce Generated by the calculator
        calc_charge = atom_cp.get_charges()
        self.calc_properties['energy'] = calc_e
        self.calc_properties['charge'] = calc_charge

        self.Gfunc_data = SymmFuncInd.symm_func_mol(atom_cp, self.at_idx_map, self.Gparam_dict)



    ### Calculate function require by ASE ###
    def calculate(self, atoms=None, properties=['energy'],
                  system_changes=all_changes):
        Calculator.calculate(self, atoms, properties, system_changes)


        self.initialize(self.atoms)

        denergy = calculate_subnet_energy_mol(self.subnet_list, self.Gfunc_data,
                                                    self.at_idx_map, self.n_atoms)

        #self.atoms.set_calculator(self)
        energy = self.calc_properties['energy'] + denergy  + self.dE_ref # DFTB + NN Correction

        # Calculate Numerical Force at 0.001 Angstrom
        dforce, force = self.calculate_numerical_forces(self.atoms, d=0.001)
        #energy = 0
        stress = np.zeros(6)


        self.results['energy'] = energy
        self.results['forces']  = force
        self.results['stress'] = stress
        self.results['dforces'] = dforce
        self.results['denergy'] = denergy


    """
    ##########

    Methods for Importing the Neural Network Model.

    ##########
    """



    def import_model(self, model_name, subnet_str_list):
        """Assumes all models are saved in the "src.models/" directory,
        import all the elemental sub-neural network.

                Args:
                    model_name: the folder name that contains the model
                    subnet_str_list: list of subnet str in the form
                            ['H', 'O', 'C', 'N']

                Effect:
                    Load the entire Keras model.

        Comments:
        Junmian Zhu's experiments on the iPython notebook indicates that if directly
        load the keras.model.h5, and then get the sub-neural network, it would
        lose the name of each subnet. Therefore, it is recommended to use the
        load the weights and the model.json file for each sub neural network.
        """

        save_dir = DirNav.get_model_dir(model_name)
        try:
            self.subnet_list = pack_subnet_list(save_dir, subnet_str_list)
        except:
            ImportError("ModelCalc::import_model failed")

        Gparam_file = 'Gparam_dict.pkl'

        try:
            self.Gparam_dict = ModelIO.read_data_from_pickle(save_dir, Gparam_file)
        except:
            raise ImportError("ModelCalc::import_model unable to read Gparam_dict and at_idx_map")

        try:
            rel_e_arr = pd.read_pickle(os.path.join(save_dir, "rel_e_ref.pkl"))
        except:
            raise ImportError("ModelCalc::import_model unable to read reference energy")
        # Test whether the model has been successfully imported
        if self.subnet_list != None:
            print("Successfully Imported the training model")
        else:
            print("Failed to import the training model")
        self.e_ref_dft = rel_e_arr['dft']
        self.e_ref_calc = rel_e_arr['calc']

        # Get the number of symmetry function by the input shape
        # Input_shape = [n_samples, n_symm_func]
        #TODO: Assumes that each subnet has the same No. symm function
        any_ele = subnet_str_list[0]
        self.n_symm_func = self.subnet_list[any_ele].layers[0].input_shape[1]




    def update_model(self, model):
        """
        Update the model from the trained keras model (not from .h5 file)
            Args:
                model: keras.models
        See YNN.get_model function.
        """
        pass


    ### Export the model used by the instance
    def export_model(self, h5_file_path):
        """
        Export the model to the given path as a .h5 file.
            Args:
                h5_file_path: a file path str that would save the h5 name. End in '.h5'
        """
        pass


    def get_model(self):
        """
        Return the model used by the instance.
        See YNN.update_model function.
        """
        pass





    """
    ##########

    Methods for Calculation.

    ##########
    """


    def get_dforces(self, atoms=None):
        "Get the Delta Force"
        return self.get_property('dforces', atoms)

    def get_denergy(self, atoms=None):
        "Get the delta Energy by model prediction"
        return self.get_property('denergy', atoms)



    def calculate_numerical_forces(self, atoms, d=0.00001):
        """ The same method provided by ASE is not working because of exceeding
        maximum recursion.

        Even though this method has no _mol post-fix,
        It includes calculations for the numerical force for the entire molecule.

        Without DFTB+ Energy Contribution.
            Args:


            Outputs:
                force_df: at index = derivative
                    force_df[atom_idx][xyz_str] = numerical force
        Comments:
        For Testing Purpose Onlyself.
        Cannot be directly put into the calculator class since a calculator
        cannot contain an instance of itself.
        """
        n_atoms = self.n_atoms
        atom_idx_arr = np.arange(n_atoms)
        xyz_arr = np.array(['x', 'y', 'z'])


        dforce_arr = np.zeros((n_atoms, 3) )
        force_arr = np.zeros((n_atoms, 3))

        for atom_idx in atom_idx_arr:
            for xyz_str in xyz_arr:
                shaked_atoms_plus = ForceNum.shake_mol_atom_posit(atoms, atom_idx, xyz_str, d)
                shaked_atoms_plus.set_calculator(self.calc)
                plus_dftb_e = shaked_atoms_plus.get_potential_energy()

                plus_Gfunc = SymmFuncInd.symm_func_mol(shaked_atoms_plus, self.at_idx_map, self.Gparam_dict)

                e_plus = calculate_subnet_energy_mol(self.subnet_list, plus_Gfunc, self.at_idx_map, self.n_atoms)


                """
                In Particular, the force get_potential_energy() part must be implemented
                inside the calculator rather than assign a new calculator.
                """

                shaked_atoms_minus = ForceNum.shake_mol_atom_posit(atoms, atom_idx, xyz_str, -d)
                shaked_atoms_minus.set_calculator(self.calc)
                minus_dftb_e= shaked_atoms_minus.get_potential_energy()




                minus_Gfunc = SymmFuncInd.symm_func_mol(shaked_atoms_minus, self.at_idx_map, self.Gparam_dict)
                e_minus = calculate_subnet_energy_mol(self.subnet_list, minus_Gfunc, self.at_idx_map, self.n_atoms)


                xyz_num = xyz_str_dict[xyz_str]
                dforce_arr[atom_idx][xyz_num]= -ForceNum.force_calc_3p(e_minus, e_plus, d)
                force_arr[atom_idx][xyz_num] = -ForceNum.force_calc_3p(e_minus+minus_dftb_e , e_plus+plus_dftb_e, d)
        return dforce_arr, force_arr






def calculate_subnet_energy_mol(subnet_list, Gfunc_data, at_idx_map, n_atoms):
    """Calculate the total energy using the list of sub-nerual network.

            Args:
                subnet_list: the list of elemental subnet
                    subnet_list['h'] = H_subnet
                Gfunc_data: symmetry function values for one molecule
                at_idx_map: atom index map
                n_atom: (Just for performance, not necessary for processing)
                        number of atoms

            Outputs:
                total_energy: total energy for a given molecule calculated
                              by the neural network


    Currently, This function is only designed for the symmetry function
    without feature. For Feature suppot, please refer to :
    calculate_subnet_energy_total function
    """
    atom_e = np.zeros(n_atoms)
    for element in at_idx_map:
        for at_idx in at_idx_map[element]:
            Gfunc_ind = Gfunc_data[element][at_idx]
            atom_e[at_idx] = subnet_list[element].predict(Gfunc_ind)

    return np.sum(atom_e)

def pack_subnet_list(save_dir, subnet_str_list):
    """Read an list of sub-neural networks based on the list from the directory

            Args:
                save_dir: directory with the subnet weights and .json model
                subnet_str_list: list of subnet str in the form
                        ['H', 'O', 'C', 'N']

    Comments:
    Will Load from subnet weights and the .json file
    """
    subnet_list = {}
    for subnet_str in subnet_str_list:
        try:
            subnet_name = subnet_str + '-subnet'
            subnet_list[subnet_str] = ModelIO.read_keras_subnet_ind(save_dir, subnet_name)
        except:
            raise ImportError("pack_subnet_list: error while import subnet " + subnet_name)
    return subnet_list

