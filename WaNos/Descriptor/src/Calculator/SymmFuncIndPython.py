"""


This is the module for the processing of symmetry function
for individual molecules.


"""


import math # Faster than Numpy for scaler operations

# Import Symmetry Functions
# Then wrap it for individual ones.
import pandas as pd
import src.Calculator.src_nogrd as src_nogrd
import matplotlib.pyplot as plt
import numpy as np






# Mode Specification:
# Turn on PRINT MODE
PRINT_MODE = False





def radial_filter_ind(Rs, eta, Rij):
    """radial filter for symmetry functions
    # Arguments
        Rs, eta: radial symmetry function parameters; float
        Rij: distance values between two given atoms i and j;
                1D numpy array of length Nsamples

    # Returns
        G_rad_ij: radial filter values; 1D numpy array of length nb_samples
    """
    G_rad_ij = math.exp(-eta * (Rij-Rs)**2)
    return G_rad_ij


# Angular Filter Function is the Angular Symmetry Function
# For a given set of (eta, zeta, lambd), caclaulte
# The augular component of G value for all the neighbour atoms

# To change the filter function, modify it here.
def angular_filter_ind(Rij, Rik, Rjk, eta, zeta, lambd):
    """angular filter for angular symmetry functions
    # Arguments
        eta, zeta, lambd: angular symmetry function parameters
        Rij, Rik, Rjk: distances among three atoms i, j, k; 1D arrays of length nb_samples

    # Returns
        G_ang_ij: angular filter values; 1D numpy array of length nb_samples

    """
    cos_angle = (Rij**2 + Rik**2 - Rjk**2)/(2.0 * Rij * Rik)
    rad_filter = math.exp(-eta*(Rij + Rik + Rjk)**2)
    G_ang_ijk = 2**(1.0-zeta) * (1.0 + lambd * cos_angle)**zeta * rad_filter


    return G_ang_ijk


def symm_func_mol_arr(distance_arr, at_ele_arr,
                        neighbourlist_arr, neighbourpair_arr,
                        count_Gparam, count_dict,
                        ang_list,
                        n_atoms, n_symm_func):
    """
    Refactor the entire symmetry function calculation into
    arr operations to speed up.

    (count refers to the symmetry function vector count )

            Args:

                distance_arr: distances array
                            (Generated by distance_arr_generator function )
                at_ele_arr: return the element for a given atom index.
                            (Reverse dictionary of at_idx_map)
                neighbourlist_arr: np.array, return the structure of the
                            neighbourlist for the given atom.
                            neighbourlist_arr[at_idx] = [neightbour atom idx]
                            (For use in radial symmetry function)
                neighbourpair_arr: np.array, return the structure of the
                            all the neightbour pairs of the given atom.
                            neightbourpari_arr[at_idx]
                            = [(at1, at2)] (at1 and at2 are neighbours of the
                                            given atom with index of at_idx)


                count_Gparam: a np.array that has the structure
                            count_Gparam[count]  = Gparam_list (specified for the given count)

                            count_Gparam = (count, max No. Params)

                count_dict: Return the count for the given atom
                            count_dict['element'] = [counts for that element]
                            count_dict['elemental pair'] = [counts for that elemental pair]

                n_atoms: number of atoms
                n_symm_func: number of symmetry functions


            Outputs:

               Gfunc_data: symmetry function values;
                            dictionary with 1st layer keys = atom types,
                                2nd layer keys = atom indexes,
                                values = 2D arrays with shape=(1, n_symm_func)

                            Gfunc_data[element][at_idx] = (1, n_symm_func)

               (New) Gfunc_data[at_idx] = (1, n_symm_func)
               New Data structure should be adopted when the input can be organzied.
               It is much more organized since this is an numpy array.
               Even though The New Data structure looks like it only supports
               fixed number of atoms, since the data will be converted into input,
               it is still able to work with multiple different arrays.

    Comments:
    Working In Progress.
    Only designed the framework, not implemented yet.

    Attention:
    Neighbour list will change with different configurations.
    A simpler way might be to loop through every of the atom, and then
    just check for the distances .


    """



    Gfunc_data = np.zeros(shape=(n_atoms, 1, n_symm_func)) # New Gfunc structure

    # This for loop goes through all atoms
    for at_idx_i in np.arange(n_atoms):

        # This for loop goes through all neighbours of the atom
        # For the Radial Components
        for at_idx_j in neighbourlist_arr[at_idx_i]:
            Rij = Calculation.get_distance(at_idx_i, at_idx_j, n_atoms, distance_arr)
            at_j_ele = at_ele_arr[at_idx_j]


            # Get the corresponding counts in the vector
            for symm_count in count_dict[at_j_ele]:
                rad_params = count_Gparam[symm_count]
                Rs = rad_params[0]
                eta = rad_params[1]
                Gfunc_data[at_idx_i,0, symm_count] += radial_filter_ind(Rs, eta, Rij)


        # This for loop goes through all neighbours pairs of the atoms
        # For the angular components
        # Go through all the neighbour pairs
        for neighbour_pair in neighbourpair_arr[at_idx_i]:
            at_idx_j = neighbour_pair[0]
            at_idx_k = neighbour_pair[1]
            Rij = Calculation.get_distance(at_idx_i, at_idx_j, n_atoms, distance_arr)
            Rik = Calculation.get_distance(at_idx_i, at_idx_k, n_atoms, distance_arr)
            Rjk = Calculation.get_distance(at_idx_j, at_idx_k, n_atoms, distance_arr)

            at_i_ele = at_ele_arr[at_idx_i]
            at_j_ele = at_ele_arr[at_idx_j]
            at_k_ele = at_ele_arr[at_idx_k]

            pair_jk = Calculation.get_pair(at_j_ele, at_k_ele, ang_list)


            # Get the corresponds counts in the vector
            for symm_count in count_dict[pair_jk]:
                ang_params = count_Gparam[symm_count]
                eta = ang_params[0]
                zeta = ang_params[1]
                lambd = ang_params[2]

                Gfunc_data[at_idx_i, 0, symm_count] += angular_filter_ind(Rij, Rik, Rjk, eta, zeta, lambd)

    return Gfunc_data







def symm_func_mol_compiled(atoms, at_ele_arr,
                        count_Gparam, count_dict,
                        ang_list,
                        n_atoms, n_symm_func):
    """A wrapper for the compiled version of symmetry function.


    Will:
        Calculate the distance for the given molecule.
        Calculate the neighbour list for the given molecule.

    TODO:
    Change this function because this is too unelegant.
    """
    md_samplesArr = pd.Series([atoms])
    n_atoms, xyzArr = src_nogrd.xyzArr_generator(md_samplesArr)
    distance_arr = Calculation.distance_xyz_brutal_mol(xyzArr, n_atoms)

    neighbourlist_arr, neighbourpair_arr = Calculation.get_neighbour(distance_arr, n_atoms)

    Gfunc_data = symm_func_mol_arr(distance_arr, at_ele_arr,
                                    neighbourlist_arr, neighbourpair_arr,
                                    count_Gparam, count_dict,
                                    ang_list,
                                    n_atoms, n_symm_func)
    return Gfunc_data, xyzArr, distance_arr, neighbourlist_arr, neighbourpair_arr









def symm_func_show_ind(Gfunc_data_ind):
    """
    Generate a plot of the symmetry function (Gfunc_data) of an atom with index (at)
    Raise Error When the array have nan.

        Args:
                Gfunc_data_ind: Symmetry Function Vector For Individual Atom
                                a np.array of shape (1, n_symm)

        Outputs:
                No. Only Generates the Graph.
    """

    n_symm = Gfunc_data_ind.shape[1]


    x_index = np.arange(n_symm)


    plt.plot(n_symm, Gfunc_data_ind)
    plt.show()
    return










"""
#########

Symmetry Function For Molecules:
(For Numerical Calculation)
(Just Wrappers)

#########
"""


def symm_func_mol(atoms, at_idx_map, Gparam_dict):
    """Just a Wrapped to Create the Symmetry Function for a given molecule

            Outputs:
                Gfunc_mol: Symmetry Function For the given molecule
                        Same Strcture as Gfunc_data
                        Gfunc_data[element][atom_idx] = (1, n_symm_func)
                        Number of Symmetry Function 1.
    Assumes that all the configurations have the same at_idx_map
    """
    md_samplesArr = pd.Series([atoms])
    nAtoms, xyzArr = src_nogrd.xyzArr_generator(md_samplesArr)
    distances = src_nogrd.distances_from_xyz(xyzArr, nAtoms)

    # Assume that Gparam_dict and at_idx_map is the save for all the
    # configurations
    # It is possible to generate at_idx_map for each individual configurations
    # That will consume much more time
    Gfunc_mol = src_nogrd.symmetry_function(distances, at_idx_map, Gparam_dict)
    return Gfunc_mol


def feat_func_mol(at_idx_map, md_feat):
    """ Prepare the Feature array for individual feat functions. """
    return src_nogrd.feat_function(at_idx_map, md_feat, 1)
















"""
##########

Dealing with Inputs

###########
"""








def get_inp(at_idx_map, Gfunc_scaled, Feat_scaled=None):
    """Prepare the input file for the neural network

            Args:
                at_idx_map: atom index map
                Gfunc_scaled: scaled symmetry function
                            Gfunc_data[element][atom_idx] = (1, n_symm_func)
                Feat_scaled: scaled Feature functions
                            Feat_data[element][atom_idx] = (1, n_feat)
                            By Default it is equal to None.

    Comments:
    Suprisingly, this function works for both one molecule and multiple
    Configurations since they have the same input shape
    The 1 mentioned above can be replaced by n_samples.
    """
    inp_arr = []
    for at_type in at_idx_map.keys():
        for at_idx in at_idx_map[at_type]:
            inp_arr.append(Gfunc_scaled[at_type][at_idx])
            if Feat_scaled != None:
                inp_arr.append(Feat_scaled[at_type][at_idx])
            else:
                continue

    return inp_arr


def get_atoms_inp(atoms, at_idx_map, Gparam_dict, feat_arr=None, mode="old"):
    if feat_arr == None:
        Feat_data = None
    else:
        Feat_data  = feat_func_mol(at_idx_map, [feat_arr])

    if mode == "old":
        Gfunc_data = symm_func_mol(atoms, at_idx_map, Gparam_dict)
        #import pdb; pdb.set_trace()
        input = get_inp(at_idx_map, Gfunc_data, Feat_data)
    elif mode == 'compiled':
        Gfunc_data = symm_func_mol_compiled()
    return input
